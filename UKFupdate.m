function [S, P]= UKFupdate(u, xyzPost, S, P, A, Q, R, typ)                                       
                                         
% функция обновления оценок координат ИРИ сигма-точечным фильтром (СТФ,
% Unscented Kalman Filter,)поизмерения частоты Доплера неподвижным 
% измерительным постом
%
% u - вектор измерения 
% S - вектор состояния
% P - ковариационная матрица прогешности оценивания 
% A - матрица перехода марковской модели процесса движения ИРИ
% Q - ковариационная матрица шума процесса двтжения
% R - ковариационная матрица шума измерения 
%
% var@mail.spbstu.ru, V.A. Vargauzin, октябрь 2015, декабрь 2020

xhat=S;
if size(S,2) > 1
    xhat=xhat';
end
% xhat - вектор-столбец

if size(u,2) > 1
    u=u';
end
% u - вектор-столбец

    n=6; % = numel(xhat)
    n2=2*n; 
    SIGMAm = zeros(n,n2); % буфер для хранения предсказанных
    % сигма точек состояния (каждая точка - вектор состояния)
%     m=1; % размер вектора измерения = numel(u)
    m=numel(u);
    Z = zeros(m,n2); % буфер для хранения предсказанных сигма
    % точек измерения (каждая точка - вектор измерения) 

    % вектор-столбец измерения:
    y=u; 

    % Нахождение 2n сигма точек состояния (xhat,P -> SIGMA):
    SIGMA = ukf_sigmapoints(xhat,P);

    % Вычисление предказания для каждой из сигма точек SIGMA
    % (SIGMA -> SIGMAm):
    for j = 1:n2
        SIGMAm(:,j) = updatex(SIGMA(:,j),A);
    end

    % Вычисление общего предсказания (среднего xm и ковариационной 
    % матрицы Pm) по всем 2n точкам  SIGMAm (SIGMAm -> xm, Pm):
    [xm, Pm] = ukf_mean_covariance(SIGMAm);
    Pm = Pm + Q;

    % Вычисление 2n сигма точек измерений (предсказаний измерений Z для 
    % всех SIGMAm) (SIGMAm -> Z): 
    for j = 1:n2
        Z(:,j) = h(SIGMAm(:,j));                   
    end

    % Вычисление общего предсказания измерения 
    % (среднего z и ковариационной матрицы Pz) по
    % всем 2n предсказанным измерениям Z (Z -> z, Pz):
    [z, Pz] = ukf_mean_covariance(Z);
    Pz = Pz + R;
    
    % Нахождение взаимно-ковариационной матрицы между сигма точками 
    % SIGMAm и Z: 
    Pxz = ukf_covariance(SIGMAm, Z); % вектор-строка размера n

    K = Pxz/Pz;            % Матрица усиления Калмана
    xhat = xm + K*(y - z); % обновление вектора состояния
    P = Pm - K*Pz*K';      % обновление ковариационной матрицы
    P = 0.5*(P+P');        % обеспечение числовой стабильности

    S=xhat;
    if size(S,2) > 1
        S=S';
    end
     
%--------------------------------------------------

% Функция связи между вектором измерения и координатами вектора состояния:
function y = h(xhat) 

    sat=[xhat(1) xhat(2) xhat(3)];
    sat_v=[xhat(4) xhat(5) xhat(6)];
    freqDownlink=0; % несущая равна нулю, посколку в качестве измерения 
    % используется не частота Доплера, а линейно с ней связанная проекция
    % вектора скорости 
    [~,a]=dopplerSAT1_downLink(sat,...
                               sat_v,...
                               xyzPost,...
                               freqDownlink);
    if typ==1    
         y=a';
    else
        y=[a sat sat_v]';                         
    end
   
end

%--------------------------------------------------
% функция обновления вектора состояния:
function xo = updatex(x,A)
    xo = A*x;
end

%--------------------------------------------------
% функция вычисления сигма точек:
function X = ukf_sigmapoints(xbar,Pi) 
    nn = size(xbar,1);
    B = chol(nn*Pi)'; % R = chol(B) where R'*R = B
    X = [B -B] + repmat(xbar,1,nn*2);
end
 
%--------------------------------------------------
% функция вычисления среднего (и ковариации) по множеству сигма-точек:
function [m, P] = ukf_mean_covariance(sigmaX) 
    n_2 = size(sigmaX,2);
    m = sum(sigmaX,2)/n_2;
    P = zeros(size(sigmaX,1)); % size n
    for k = 1:n_2
        P = P + ((sigmaX(:,k)-m)*(sigmaX(:,k)-m)');
    end
    P = P/n_2;
end
 
%--------------------------------------------------
% Функция вычисления взаимной ковариации между двумя множествами 
% сигма точек (состояния и измерения):
function P = ukf_covariance(sigmaX, sigmaY) 
    n_2 = size(sigmaX,2); 
    mx = sum(sigmaX,2)/n_2;
    my = sum(sigmaY,2)/n_2;
    P = zeros(size(sigmaX,1),size(sigmaY,1)); % size n
    for k = 1:n_2
        P = P + ((sigmaX(:,k)-mx)*(sigmaY(:,k)-my)');
    end
    P = P/n_2;
end 
            
end
       
